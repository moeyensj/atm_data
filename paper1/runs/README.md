### Data Contents

This directory contains Python scripts, slurm run scripts and the results databases for different thermal modeling runs (with varying priors and fit configurations).

The result's databases were originally generated by `atm.multiFit` and then post-processed (see: [post_processing.ipynb](https://github.com/moeyensj/atm_notebooks/blob/master/paper1/analysis/post_processing.ipynb)). 

| Table | Generated By | Description |
|---|---|---|
| model_observations | `atm.multiFit` | Observations generated using best-fit model parameters |
| summary | `atm.multiFit` | Summary of fitting results | 
| observations_pp | `atm.analysis.postProcessDatabase` | Input observations with added columns for analysis |
| model_observations_pp | `atm.analysis.postProcessDatabase` | Model observations with calculated magnitude residuals, color residuals and chi squared | 
| observed_stats_pp | `atm.analysis.postProcessDatabase`| Medians and robust standard deviations of all observed quantities for each asteroid |
| model_stats_pp | `atm.analysis.postProcessDatabase` | Medians, robust standard deviations, reduced chi squareds of modeling results for each asteroid | 


### Result Databases
| Dataset | Fit Parameters | Emissivity Priors | Albedo Priors | Fit Filters | Model in Paper |
|---|---|---|---|---|---|
| [atm_results_run0.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run0.db) | $logD$, $logT1$, $\epsilon$ | Flat $\epsilon$ | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | - | 
| [atm_results_run1.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run1.db) | $logD$, $logT1$, $\epsilon_{W1W2}$ |  $\epsilon_{W3W4}$ = 0.9 | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | Model 1 |
| [atm_results_run2a.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run2a.db) | $logD$, $logT1$, $\epsilon_{W1W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.70, 0.86)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ |  W1,W2,W3,W4 | Model 2 |
| [atm_results_run2b.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run2b.db) |  $logD$, $logT1$, $\epsilon_{W1}$, $\epsilon_{W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.70, 0.86)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | - |
| [atm_results_run3a.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run3a.db) | $logD$, $logT1$, $\epsilon_{W1W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.76, 0.93)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | Model 3 |
| [atm_results_run3b.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run3b.db) | $logD$, $logT1$, $\epsilon_{W1}$, $\epsilon_{W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.76, 0.93)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | - |
| [atm_results_run4a.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run4a.db) | $logD$, $logT1$, $\epsilon_{W1W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.80, 0.98)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | Model 4 |
| [atm_results_run4b.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run4b.db) | $logD$, $logT1$, $\epsilon_{W1}$, $\epsilon_{W2}$ |  $\epsilon_{W3}, \epsilon_{W4}$ = (0.80, 0.98)  | Kirchoff $\left( p = \frac{1 - \epsilon}{q(G)} \right)$ | W1,W2,W3,W4 | Model 5 |
| [atm_results_run5a.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run5a.db ) | $logD$, $logT1$, $p_{W1W2}$ |  $\epsilon$ = 0.9  | $p_{W3W4}$ = 0.0 | W1,W2,W3,W4 | - |
| [atm_results_run5b.db](https://github.com/moeyensj/atm_data/blob/master/paper1/runs/atm_results_run5b.db) | $logD$, $logT1$, $p_{W1W2}$ |  $\epsilon$ = 0.9  | $p_{W3W4}$ = 0.0 | W1,W3,W4 | - |


### Run Descriptions 

For each of the runs described below, we used the following fit configuration (see `config.yml`):

```
# Create fit configuration
fitConfig = {
    "chains" : 25,
    "samples" : 3000,
    "burnInSamples": 500,
    "threads": 25,
    "scaling": 0.01,
    "plotTrace" : True,
    "plotCorner" : True,
    "progressBar" : False,
}
```

### Run 0 - Constant Emissivity 

In this run, we assume a constant (flat) emissivity as a function of wavelength. We fit
for logD, logT1, and emissivity (eps).

```
RUN_NAME = "run0"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps"],
    "emissivitySpecification" : None,
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : None,
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```
### Run 1 - Nathan's Run 

In this run, we assume emissivity in W3 and W4 is 0.9 (eps_W3W4). We fit
for logD, logT1, a single emissivity in W1 and W2 (eps_W1W2).

```
RUN_NAME = "run1"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3W4"] = np.ones(len(observations)) * 0.9 

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1W2"],
    "emissivitySpecification" : {
                "eps_W1W2" : ["W1","W2"],
                "eps_W3W4" : ["W3","W4"]},
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```
### Run 2a - Track 1, 3 Parameters 

We now assume that emissivity in W3 and W4 is 0.70 and 0.86, respectively. We fit
for logD, logT1, a single emissivity in W1 and W2 (eps_W1W2). 
```
RUN_NAME = "run2a"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.70
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.86

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1W2"],
    "emissivitySpecification" : {
                "eps_W1W2" : ["W1","W2"],
                "eps_W3" : ["W3"],
                "eps_W4" : ["W4"]},
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
    
```
### Run 2b - Track 1, 4 Parameters 

Using the same assumptions as run2a, we now fit for two emissivities, one in W1 (eps_W1) and one in W2 (eps_W2), in addition
to logD and logT1.

```
RUN_NAME = "run2b"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.70
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.86

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1", "eps_W2"],
    "emissivitySpecification" : "perBand",
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```

### Run 3a - Track 2, 3 Parameters 

We now assume that emissivity in W3 and W4 is 0.76 and 0.93, respectively. We fit
for logD, logT1, a single emissivity in W1 and W2 (eps_W1W2). 
```
RUN_NAME = "run3a"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.76
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.93

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1W2"],
    "emissivitySpecification" : {
                "eps_W1W2" : ["W1","W2"],
                "eps_W3" : ["W3"],
                "eps_W4" : ["W4"]},
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
    
```
### Run 3b - Track 2, 4 Parameters 

Using the same assumptions as run3a, we now fit for two emissivities, one in W1 (eps_W1) and one in W2 (eps_W2), in addition
to logD and logT1.

```
RUN_NAME = "run3b"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.76
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.93

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1", "eps_W2"],
    "emissivitySpecification" : "perBand",
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```

### Run 4a - Track 3, 3 Parameters

We now assume that emissivity in W3 and W4 is 0.80 and 0.98, respectively. We fit
for logD, logT1, a single emissivity in W1 and W2 (eps_W1W2). 
```
RUN_NAME = "run4a"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.80
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.98

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1W2"],
    "emissivitySpecification" : {
                "eps_W1W2" : ["W1","W2"],
                "eps_W3" : ["W3"],
                "eps_W4" : ["W4"]},
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
    
```
### Run 4b - Track 3, 4 Parameters 

Using the same assumptions as run4a, we now fit for two emissivities, one in W1 (eps_W1) and one in W2 (eps_W2), in addition
to logD and logT1.

```
RUN_NAME = "run4b"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps_W3"] = np.ones(len(observations)) * 0.80
dataDict[RUN_NAME]["eps_W4"] = np.ones(len(observations)) * 0.98

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "eps_W1", "eps_W2"],
    "emissivitySpecification" : "perBand",
    "albedoSpecification": "auto",
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : ["eps_W3", "eps_W4"],
                "p" : None,
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```
### Run 5a - NEOWISE 
Here we attempt to reproduce the NEOWISE fitting scenario (which violates Kirchoff's law). Instead of 
fitting for emissivity in bands W1 and W2, we fit for albedo in those bands (p_W1W2) and logD, logT1. 
We set a flat epsilon across all bands equal to 0.9. In bands W3 and W4 we set albedo to 0.0 (p_W3, p_W4). 

```
RUN_NAME = "run5a"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps"] = np.ones(len(observations)) * 0.9
dataDict[RUN_NAME]["p_W3"] = np.ones(len(observations)) * 0.0
dataDict[RUN_NAME]["p_W4"] = np.ones(len(observations)) * 0.0

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "p_W1W2"],
    "emissivitySpecification" : None,
    "albedoSpecification": {
                "p_W1W2" : ["W1", "W2"],
                "p_W3" : ["W3"],
                "p_W4" : ["W4"]},
    "fitFilters" : "all",
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : "eps",
                "p" : ["p_W3", "p_W4"],
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```

### Run 5b - NEOWISE (Ignoring W2)
Here we repeat run5a, but this time ignore any data in W2.

```
RUN_NAME = "run5b"

# Create data dictionary
dataDict = {}
dataDict[RUN_NAME] = observations.copy()
dataDict[RUN_NAME]["eps"] = np.ones(len(observations)) * 0.9
dataDict[RUN_NAME]["p_W3"] = np.ones(len(observations)) * 0.0
dataDict[RUN_NAME]["p_W4"] = np.ones(len(observations)) * 0.0

# Create fit dictionary
fitDict = {}
fitDict[RUN_NAME] = {
    "fitParameters" : ["logT1", "logD", "p_W1W2"],
    "emissivitySpecification" : None,
    "albedoSpecification": {
                "p_W1W2" : ["W1", "W2"],
                "p_W3" : ["W3"],
                "p_W4" : ["W4"]},
    "fitFilters" : ["W1", "W3", "W4],
    "columnMapping" : {
                "obs_id" : "obs_id",
                "designation" : "designation",
                "exp_mjd" : "mjd",
                "r_au" : "r_au",
                "delta_au" : "delta_au",
                "alpha_rad" : "alpha_rad",
                "eps" : "eps",
                "p" : ["p_W3", "p_W4"],
                "G" : "G",
                "logT1" : None,
                "logD" : None,
                "flux_si" : ["flux_W1_si", "flux_W2_si", "flux_W3_si", "flux_W4_si"],
                "fluxErr_si" : ["fluxErr_W1_si", "fluxErr_W2_si", "fluxErr_W3_si", "fluxErr_W4_si"],  
                "mag" : ["mag_W1", "mag_W2", "mag_W3", "mag_W4"],
                "magErr" : ["magErr_W1", "magErr_W2", "magErr_W3", "magErr_W4"]
    }
}
```